# Arenn Banks
# SID: @03102572

import re

class Boggle:
  def __init__(self, grid, dictionary):
      self.grid = grid
      self.dictionary = dictionary
      self.solutions = []

  def getSolution(self):
    #1. check if input parameters are valid
    if self.grid is None or self.dictionary is None:
      return self.solutions

    #1b. Check if grid is NxN
    N = len(self.grid)
    for row in self.grid:
      if len(row) != N:
        return self.solutions

    # Convert input data into the same case
    self.convert_to_lower(self.grid, self.dictionary)

    # Check if is grid is valid
    if not self.is_grid_valid(self.grid):
      return self.solutions

    # Setup all data structures
    solution_set = set()
    trie = self.create_trie(self.dictionary)

    # Iterate over the NxN  grid - find all words that begin with grid[x][y]
    for x in range(N):
      for y in range(N):
        word = ""
        visited = [[False for _ in range(N)] for _ in range(N)]
        self.find_words(word, x, y, self.grid, visited, trie, solution_set)

    self.solutions = list(solution_set)
    return self.solutions

  class Node:
    def __init__(self):
      self.children = {}
      self.is_end_of_word = False

  class Trie:
    def __init__(self):
      self.root = Boggle.Node()

    def insert(self, word):
      current = self.root
      for char in word:
        if char not in current.children: 
          current.children[char] = Boggle.Node()
        current = current.children[char]
      current.is_end_of_word = True

    def search(self, word):
      current = self.root
      for char in word:
        if char not in current.children:
          return False
        current = current.children[char]
      return current.is_end_of_word

    def startsWith(self, prefix):
      current = self.root
      for char in prefix:
        if char not in current.children:
          return False
        current = current.children[char]
      return True

  def create_trie(self, dictionary):
    trie = Boggle.Trie()
    for word in dictionary:
      trie.insert(word)
    return trie

  def find_words(self, word, x, y, grid, visited, trie, solution_set):

    # Base case: x and y are out of bounds or alreadsy visited
    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid) or visited[x][y]:
      return

    # Append grid[x][y] to the word
    word += grid[x][y].lower()

    # Check if the new word is a prefix for any word  in the trie
    if not trie.startsWith(word):
      return

    # Mark as visited
    visited[x][y] = True

    # Check if it's an actual word in the dictionary
    if trie.search(word) and len(word) >= 3:
      solution_set.add(word)

    # Continue searching using adjacent tiles
    for dx in [-1, 0, 1]:
      for dy in [-1, 0, 1]:
        if dx != 0 or dy != 0:
          self.find_words(word, x + dx, y + dy, grid, visited, trie, solution_set)

    # Unmark location x, y as visited
    visited[x][y] = False

  def convert_to_lower(self, grid, dictionary):
    for i in range(len(grid)):
      for j in range(len(grid[i])):
        self.grid[i][j] = grid[i][j].lower()

    for i in range(len(dictionary)):
      self.dictionary[i] = dictionary[i].lower()

  def is_grid_valid(self, grid):
    regex = r'(st|qu)|[a-z]'
    for row in grid:
      for cell in row:
        if not re.match(regex, cell.lower()):
          return False
    return True

def main():
  grid = [["T", "W", "Y", "R"], ["E", "N", "P", "H"], ["G", "St", "Qu", "R"], ["O", "N", "T", "A"]]
  dictionary = ["art", "ego", "gent", "get", "net", "new", "newt", "prat", "pry", "qua", "quart", "quartz", "rat", "tar", "tarp", "ten", "went", "wet", "arty", "not", "quar"]
  
  mygame = Boggle(grid, dictionary)
  print(mygame.getSolution())

if __name__ == "__main__":
  main()